@page "/transactions"
@inject HttpClient http
@inject AppStateContainer AppState
@inject NavigationManager navManager
@implements IDisposable


@if (AppState.Categories != null && AppState.Categories.Count > 0)
{

    <h3>Transaktioner</h3>
    <TransactionHeader FromDate="fromDate" ToDate="toDate" SetFromDate="SetFromDate" SetToDate="SetToDate" SetCurrentCategory="SetCurrentCategory" Categories="AppState.Categories" CurrentCategory="currentCategory" />
}

@if (AppState.Transactions == null && AppState.Categories == null)
{
    <p><em>Loading...</em></p>
}

else
{
    if (AppState.Categories != null && AppState.Categories.Count > 0 && AppState.Transactions != null && AppState.Transactions.Count > 0)
    {

        <TransactionBody Categories="AppState.Categories" CurrentCategory="currentCategory" FromDate="fromDate" ToDate="toDate" Index="index" PageSize="pageSize" Transactions="AppState.Transactions" />

        <nav aria-label="Page navigation example">
            <ul class="pagination">
                <li class="page-item"><div class="page-link" style="cursor: pointer" @onclick="(() => SetIndex(index - 1))">Föregående</div></li>
                @for (int i = 0; i < (GetTransactionCount() / pageSize) + 1; i++)
                {
                    var n = i;
                    <li class="page-item"><div class="page-link" style="cursor: pointer" @onclick="(() => SetIndex(n))">@(i + 1) </div></li>

                }
                <li class="page-item"><div class="page-link" style="cursor: pointer" @onclick="(() => SetIndex(index + 1))">Nästa</div></li>
            </ul>
        </nav>
    }
}

@code {
    int index = 0;
    int pageSize = 5;

    DateTime fromDate = DateTime.Today.AddMonths(-1);
    DateTime toDate = DateTime.Today;
    public Category currentCategory = new Category() { Id = null };
    public List<Transaction> transactions = new List<Transaction>();
    public List<Category> categories = new List<Category>();


    protected override async Task OnInitializedAsync()
    {
        AppState.StateChanged += async (source, property) => await AppState_StateChanged(source, property);
        if (!AppState.IsAuth)
        {
            try
            {
                var user = await ValidateSession();
                if (string.IsNullOrEmpty(user.ErrorMessage))
                {
                    await GetUser(user.UserId);
                    await GetCategories();
                    await GetTransactions();
                    await GetExpenseLimits();
                }
                else
                {
                    navManager.NavigateTo("/");
                }
            }
            catch (Exception)
            {

                navManager.NavigateTo("/");
                //throw;
            }
        }
    }

    private async Task GetCategories()
    {
        try
        {
            categories = await http.GetJsonAsync<List<Category>>("api/categories/" + AppState.User.Id);
            AppState.UpdateCategories(this, categories);

        }
        catch (Exception)
        {

            throw;
        }
    }

    private async Task<UserResponse> ValidateSession()
    {
        var user = await http.SendJsonAsync<UserResponse>(HttpMethod.Post, "/user/session", null);
        return user;
    }

    private async Task GetTransactions()
    {
        try
        {
            transactions = await http.GetJsonAsync<List<Transaction>>("api/transactions/" + AppState.User.Id);
            AppState.UpdateTransactions(this, transactions);

        }
        catch (Exception)
        {

            throw;
        }
    }
    private async Task GetUser(string userId)
    {
        var user = await http.GetJsonAsync<User>("api/user/" + userId);
        AppState.SetAuthState(this, user, true);
    }

    public void SetCurrentCategory(string categoryId)
    {
        if (categoryId == null)
        {
            currentCategory = new Category() { Id = null };
        }
        else
        {
            currentCategory = AppState.Categories.Find(x => x.Id.Equals(categoryId));
        }
    }

    private async Task GetExpenseLimits()
    {
        var expenseLimits = await http.GetJsonAsync<List<ExpenseLimit>>("api/expenselimits/" + AppState.User.Id);
        AppState.UpdateExpenseLimits(this, expenseLimits);
    }

    private int GetTransactionCount()
    {
        if (currentCategory.Id == null)
        {
            return AppState.Transactions.Count;
        }
        else
        {
            return AppState.Transactions.FindAll(x => x.CategoryId.Equals(currentCategory.Id)).Count;
        }
    }

    public void SetIndex(int i) // bör endast baseras på vilken som är nuvarande kategori.
    {
        if (i >= 0 && i <= (GetTransactionCount() / pageSize))
        {
            Console.WriteLine(i);
            index = i;
            Console.WriteLine(index);
        }
    }

    public void SetFromDate(ChangeEventArgs e)
    {
        var year = int.Parse(e.Value.ToString().Substring(0, 4));
        var month = int.Parse(e.Value.ToString().Substring(5, 2));
        var day = int.Parse(e.Value.ToString().Substring(8, 2));

        fromDate = new DateTime(year, month, day);
        Console.WriteLine(fromDate);
    }

    public void SetToDate(ChangeEventArgs e)
    {
        var year = int.Parse(e.Value.ToString().Substring(0, 4));
        var month = int.Parse(e.Value.ToString().Substring(5, 2));
        var day = int.Parse(e.Value.ToString().Substring(8, 2));

        toDate = new DateTime(year, month, day);
        Console.WriteLine(toDate);
    }

    private async Task AppState_StateChanged(ComponentBase source, string property)
    {
        if (source != this)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    void IDisposable.Dispose()
    {
        AppState.StateChanged -= async (source, property) => await AppState_StateChanged(source, property);
    }

}
